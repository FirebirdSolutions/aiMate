@page "/files"
@using AiMate.Shared.Models
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@inject ISnackbar Snackbar
@inject HttpClient Http
@inject IJSRuntime JS
@rendermode InteractiveServer

<PageTitle>Files - aiMate</PageTitle>

<MudPaper Elevation="0" Class="pa-6">
    <div class="d-flex justify-space-between align-center mb-6">
        <div>
            <MudText Typo="Typo.h5" Class="mb-1">
                <MudIcon Icon="@Icons.Material.Filled.Folder" Class="mr-2" />
                Files
            </MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary">
                Manage uploaded files and documents
            </MudText>
        </div>
        <div class="d-flex gap-2">
            <MudButtonGroup Variant="Variant.Outlined" Size="Size.Small">
                <MudIconButton Icon="@Icons.Material.Filled.GridView"
                              Color="@(_viewMode == "Grid" ? Color.Primary : Color.Default)"
                              OnClick="@(() => _viewMode = "Grid")"
                              Title="Grid View" />
                <MudIconButton Icon="@Icons.Material.Filled.ViewList"
                              Color="@(_viewMode == "List" ? Color.Primary : Color.Default)"
                              OnClick="@(() => _viewMode = "List")"
                              Title="List View" />
            </MudButtonGroup>
            <MudFileUpload T="IReadOnlyList<IBrowserFile>" FilesChanged="HandleFileUpload">
                <ActivatorContent>
                    <MudButton Variant="Variant.Filled"
                              Color="Color.Primary"
                              StartIcon="@Icons.Material.Filled.CloudUpload">
                        Upload Files
                    </MudButton>
                </ActivatorContent>
            </MudFileUpload>
        </div>
    </div>

    <div class="d-flex gap-2 mb-4">
        <MudTextField T="string"
                     @bind-Value="_searchQuery"
                     Placeholder="Search files..."
                     Adornment="Adornment.Start"
                     AdornmentIcon="@Icons.Material.Filled.Search"
                     Margin="Margin.Dense"
                     Immediate="true"
                     DebounceInterval="300"
                     Style="flex: 1;" />

        <MudSelect T="string" @bind-Value="_fileTypeFilter" Label="Type" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true">
            <MudSelectItem T="string" Value="@("All")">All Types</MudSelectItem>
            <MudSelectItem T="string" Value="@("Image")">Images</MudSelectItem>
            <MudSelectItem T="string" Value="@("Document")">Documents</MudSelectItem>
            <MudSelectItem T="string" Value="@("Code")">Code</MudSelectItem>
            <MudSelectItem T="string" Value="@("Other")">Other</MudSelectItem>
        </MudSelect>
    </div>

    @if (_isLoading)
    {
        <div class="d-flex justify-center pa-8">
            <MudProgressCircular Indeterminate="true" />
        </div>
    }
    else if (!FilteredFiles.Any())
    {
        <div class="d-flex flex-column align-center justify-center pa-8">
            <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Size="Size.Large" Color="Color.Secondary" Class="mb-4" />
            <MudText Typo="Typo.h6" Color="Color.Secondary" Class="mb-2">No files uploaded</MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">Upload your first file to get started</MudText>
        </div>
    }
    else if (_viewMode == "Grid")
    {
        <MudGrid Spacing="2">
            @foreach (var file in FilteredFiles)
            {
                <MudItem @key="file.Id" xs="12" sm="6" md="4" lg="3">
                    <MudCard Class="cursor-pointer" @onclick="@(() => OpenFile(file))">
                        <MudCardMedia>
                            <div style="height: 140px; background: #2A2A2A; display: flex; align-items: center; justify-center;">
                                <MudIcon Icon="@GetFileIcon(file)" Color="Color.Primary" Style="font-size: 48px;" />
                            </div>
                        </MudCardMedia>
                        <MudCardContent>
                            <MudText Typo="Typo.body1" Class="mb-1" Style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                @file.Name
                            </MudText>
                            <div class="d-flex justify-space-between align-center">
                                <MudChip T="string" Size="Size.Small" Color="Color.Default">@file.Type</MudChip>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @FormatFileSize(file.Size)
                                </MudText>
                            </div>
                            <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-2">
                                @file.UploadedAt.ToString("MMM dd, yyyy")
                            </MudText>
                        </MudCardContent>
                        <MudCardActions>
                            <MudIconButton Icon="@Icons.Material.Filled.Download"
                                         Size="Size.Small"
                                         OnClick="@(() => DownloadFile(file))" />
                            <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                         Size="Size.Small"
                                         Color="Color.Error"
                                         OnClick="@(() => DeleteFile(file))" />
                        </MudCardActions>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }
    else
    {
        <MudTable T="FileDto" Items="@FilteredFiles" Hover="true" Striped="true" Dense="true" OnRowClick="@((TableRowClickEventArgs<FileDto> args) => OpenFile(args.Item))">
            <HeaderContent>
                <MudTh>Name</MudTh>
                <MudTh>Type</MudTh>
                <MudTh>Size</MudTh>
                <MudTh>Uploaded</MudTh>
                <MudTh>Actions</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Name">
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@GetFileIcon(context)" Size="Size.Small" />
                        <MudText Typo="Typo.body2">@context.Name</MudText>
                    </div>
                </MudTd>
                <MudTd DataLabel="Type">
                    <MudChip T="string" Size="Size.Small" Color="Color.Default">@context.Type</MudChip>
                </MudTd>
                <MudTd DataLabel="Size">
                    <MudText Typo="Typo.body2">@FormatFileSize(context.Size)</MudText>
                </MudTd>
                <MudTd DataLabel="Uploaded">
                    <MudText Typo="Typo.body2">@context.UploadedAt.ToString("MMM dd, yyyy HH:mm")</MudText>
                </MudTd>
                <MudTd DataLabel="Actions">
                    <MudIconButton Icon="@Icons.Material.Filled.Download"
                                 Size="Size.Small"
                                 OnClick="@(() => DownloadFile(context))" />
                    <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                 Size="Size.Small"
                                 Color="Color.Error"
                                 OnClick="@(() => DeleteFile(context))" />
                </MudTd>
            </RowTemplate>
        </MudTable>
    }
</MudPaper>

@code {
    [Parameter]
    [SupplyParameterFromQuery]
    public Guid? WorkspaceId { get; set; }

    private List<FileDto> _files = new();
    private bool _isLoading = false;
    private string _viewMode = "Grid";
    private string _searchQuery = string.Empty;
    private string _fileTypeFilter = "All";

    protected override async Task OnInitializedAsync()
    {
        if (WorkspaceId == null)
        {
            // Use a default workspace or get from user context
            // For now, use a dummy GUID - in production, get from WorkspaceState
            WorkspaceId = Guid.Parse("00000000-0000-0000-0000-000000000001");
        }

        await LoadFiles();
    }

    private async Task LoadFiles()
    {
        _isLoading = true;
        try
        {
            var response = await Http.GetFromJsonAsync<List<WorkspaceFileDto>>(
                $"/api/v1/files?workspaceId={WorkspaceId}");

            if (response != null)
            {
                _files = response.Select(MapToFileDto).ToList();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load files: {ex.Message}", Severity.Error);
            _files = new();
        }
        finally
        {
            _isLoading = false;
        }
    }

    private FileDto MapToFileDto(WorkspaceFileDto apiFile)
    {
        return new FileDto
        {
            Id = apiFile.Id,
            Name = apiFile.FileName,
            Type = DetermineFileType(apiFile.ContentType),
            Size = apiFile.FileSize,
            UploadedAt = apiFile.UploadedAt
        };
    }

    private string DetermineFileType(string contentType)
    {
        if (string.IsNullOrEmpty(contentType))
            return "Other";

        if (contentType.StartsWith("image/")) return "Image";
        if (contentType.Contains("pdf") || contentType.Contains("document") ||
            contentType.Contains("word") || contentType.Contains("text")) return "Document";
        if (contentType.Contains("text/") || contentType.Contains("application/json") ||
            contentType.Contains("javascript") || contentType.Contains("xml")) return "Code";

        return "Other";
    }

    private List<FileDto> FilteredFiles
    {
        get
        {
            var files = _files.AsEnumerable();

            if (!string.IsNullOrWhiteSpace(_searchQuery))
            {
                var query = _searchQuery.ToLower();
                files = files.Where(f => f.Name.ToLower().Contains(query));
            }

            if (_fileTypeFilter != "All")
            {
                files = files.Where(f => f.Type == _fileTypeFilter);
            }

            return files.OrderByDescending(f => f.UploadedAt).ToList();
        }
    }

    private string GetFileIcon(FileDto file)
    {
        return file.Type switch
        {
            "Image" => Icons.Material.Filled.Image,
            "Document" => Icons.Material.Filled.Description,
            "Code" => Icons.Material.Filled.Code,
            _ => Icons.Material.Filled.InsertDriveFile
        };
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private async Task HandleFileUpload(IReadOnlyList<IBrowserFile> files)
    {
        if (files == null || !files.Any() || WorkspaceId == null)
            return;

        _isLoading = true;
        var successful = 0;

        try
        {
            foreach (var file in files)
            {
                using var content = new MultipartFormDataContent();
                var fileContent = new StreamContent(file.OpenReadStream(50 * 1024 * 1024)); // 50MB max
                fileContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(file.ContentType);

                content.Add(fileContent, "file", file.Name);

                var response = await Http.PostAsync(
                    $"/api/v1/files/upload?workspaceId={WorkspaceId}",
                    content);

                if (response.IsSuccessStatusCode)
                {
                    successful++;
                }
            }

            Snackbar.Add($"Successfully uploaded {successful} of {files.Count} file(s)", Severity.Success);
            await LoadFiles(); // Refresh list
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Upload failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void OpenFile(FileDto file)
    {
        // Trigger download for now - can implement preview later
        _ = DownloadFile(file);
    }

    private async Task DownloadFile(FileDto file)
    {
        try
        {
            var response = await Http.GetAsync($"/api/v1/files/{file.Id}/download");

            if (response.IsSuccessStatusCode)
            {
                var stream = await response.Content.ReadAsStreamAsync();
                var fileName = file.Name;

                // Use JS interop to trigger download
                using var streamRef = new DotNetStreamReference(stream);
                await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);

                Snackbar.Add($"Downloading {fileName}", Severity.Success);
            }
            else
            {
                Snackbar.Add($"Download failed", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Download failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteFile(FileDto file)
    {
        // Note: MudBlazor doesn't have a built-in confirm dialog, so using Snackbar
        // In production, consider using a proper confirmation dialog
        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Delete {file.Name}?");
        if (!confirmed) return;

        try
        {
            var response = await Http.DeleteAsync($"/api/v1/files/{file.Id}");

            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add($"Deleted {file.Name}", Severity.Success);
                _files.Remove(file);
                StateHasChanged();
            }
            else
            {
                Snackbar.Add($"Delete failed", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Delete failed: {ex.Message}", Severity.Error);
        }
    }

    // DTO for file representation
    private class FileDto
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string Type { get; set; } = string.Empty;
        public long Size { get; set; }
        public DateTime UploadedAt { get; set; }
    }

    // API Response Model
    private class WorkspaceFileDto
    {
        public Guid Id { get; set; }
        public Guid WorkspaceId { get; set; }
        public string FileName { get; set; } = string.Empty;
        public string FilePath { get; set; } = string.Empty;
        public long FileSize { get; set; }
        public string ContentType { get; set; } = string.Empty;
        public string? Description { get; set; }
        public DateTime UploadedAt { get; set; }
    }
}
